image: docker:latest
include:
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_HOST: unix:///var/run/docker.sock
  IMAGE_NAME_BASE: "$CI_REGISTRY/smart-vending/spvending-managment"
  IMAGE_NAME: "$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG"
  DAST_WEBSITE: "https://spvending.uksouth.cloudapp.azure.com"
  GIT_DEPTH: "0"
stages:
  - test
  - build
  - deploy_staging
  - deploy_production
  - dast
dependency_check:
  stage: test
  tags:
    - test
  image: maven:3.9.6-eclipse-temurin-22
  script:
      - mvn org.owasp:dependency-check-maven:check
      - |
          if grep -q "<severity>Critical</severity>" target/dependency-check-report/dependency-check-report.xml; then
            echo "❌ Vulnerabilidades críticas detectadas"; exit 1;
          fi
  artifacts:
      when: always
      paths:
        - target/dependency-check-report/dependency-check-report.html
        - target/dependency-check-report/dependency-check-report.xml
      reports:
        dependency_scanning: target/dependency-check-report/dependency-check-report.xml
  rules:
    - if: $CI_COMMIT_TAG=~ /^v\d+\.\d+\.\d+$/
      when: always
sonarqube:
  image: maven:3.9-eclipse-temurin-22
  stage: test
  tags:
    - sonar
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
              git fetch origin main
              if git branch -r --contains "$CI_COMMIT_TAG" | grep -q "origin/main"; then
                echo "Iniciando análisis con SonarQube..."
                mvn clean verify
                apt-get update && apt-get install -y wget unzip
                wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
                unzip sonar-scanner-cli-5.0.1.3006-linux.zip
                mv sonar-scanner-5.0.1.3006-linux sonar-scanner
                export PATH=$PATH:$(pwd)/sonar-scanner/bin
                echo "El tag proviene de main. Ejecutando análisis..."
                sonar-scanner -X -Dsonar.projectVersion=${CI_COMMIT_TAG} -Dsonar.token=$SONAR_TOKEN
              else
                echo "El tag NO proviene de main. Saltando análisis."
              fi
            else
              echo "No es un tag. Saltando análisis."
      fi

  rules:
    - if: $CI_COMMIT_TAG=~ /^v\d+\.\d+\.\d+$/
      when: always

build_image:
  stage: build
  tags:
    - build
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        git fetch origin main
        if git branch -r --contains "$CI_COMMIT_SHA" | grep -q "origin/main"; then
                  docker build -t "$IMAGE_NAME" .
                  docker push "$IMAGE_NAME"
          else
              echo "El tag NO proviene de main. Saltando build."
        fi
          else
            echo "No es un tag. Saltando build."
      fi

  rules:
    - if: $CI_COMMIT_TAG=~ /^v\d+\.\d+\.\d+$/
      when: always

deploy_app_staging:
  stage: deploy_staging
  tags:
    - deploy
  services: []
  variables:
    COMPOSE_PROJECT_NAME: "spvending-managment-staging"
    DOCKER_HOST: "unix:///var/run/docker.sock"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        git fetch origin main
        if git branch -r --contains "$CI_COMMIT_TAG" | grep -q "origin/main"; then
          export DEPLOY_TAG="${CI_COMMIT_TAG#deploy-staging-}"
          echo "=== DESPLEGANDO VERSIÓN ==="
          docker pull "$CI_REGISTRY_IMAGE:$DEPLOY_TAG"
          docker-compose -f docker-compose-staging.deploy.yml down --remove-orphans
          docker-compose -f docker-compose-staging.deploy.yml up -d 
          echo "=== CONTENEDORES EN EJECUCIÓN ==="
          docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Ports}}"
        else
          echo "El tag NO proviene de main. Saltando build."
        fi
      else
        echo "No es un tag. Saltando build."
      fi
  after_script:
    - docker logout $CI_REGISTRY
  rules:
    - if: $CI_COMMIT_TAG=~ /^deploy-staging-v\d+\.\d+\.\d+$/

deploy_app_production:
  stage: deploy_production
  tags:
    - azure
  services: []
  variables:
    COMPOSE_PROJECT_NAME: "spvending-managment-production"
    DOCKER_HOST: "unix:///var/run/docker.sock"
  before_script:
    - echo "=== Autenticando con GitLab Registry ==="
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - |
      if [[ "$CI_COMMIT_TAG" =~ ^deploy-production-v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        git fetch origin main
        if git branch -r --contains "$CI_COMMIT_SHA" | grep -q "origin/main"; then
          echo "=== Preparando despliegue ==="
          # Crear directorio de trabajo si no existe
          mkdir -p ~/spvending/api
          cd ~/spvending/api
        
          echo "=== Copiar docker-compose desde el repositorio ==="
          cp $CI_PROJECT_DIR/docker-compose-production.deploy.yml ./
  
          echo "=== Parando contenedores existentes ==="
          docker-compose -f docker-compose-production.deploy.yml down --remove-orphans || true
          
          echo "=== Iniciando despliegue para $CI_COMMIT_TAG ===" 
          export DEPLOY_TAG="${CI_COMMIT_TAG#deploy-production-}"
          IMAGE_NAME="$CI_REGISTRY_IMAGE:$DEPLOY_TAG"
        
          echo "=== Descargando imagen $IMAGE_NAME ==="
          docker pull "$IMAGE_NAME"
        
          echo "=== Iniciando nuevos contenedores ==="
          docker-compose -f docker-compose-production.deploy.yml up -d
        
          echo "=== Verificando estado de contenedores ==="
          docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Ports}}"
        
          echo "=== Limpiando imágenes no utilizadas ==="
          docker image prune -af
          echo "=== Despliegue completado exitosamente ==="
          exit 0
        else
          echo "El tag NO proviene de main. Saltando despliegue."
          exit 0
        fi
      else
        echo "No es un tag de despliegue válido. Saltando..."
        echo "Tag recibido: $CI_COMMIT_TAG"
        echo "Formato esperado: deploy-production-v[X.Y.Z]"
        exit 0
      fi
  after_script:
      - docker logout $CI_REGISTRY
      - |
        if [ "$CI_JOB_STATUS" != "success" ]; then
          echo "=== Logs de contenedores para debug ==="
          docker-compose -f ~/deployment/docker-compose-production.deploy.yml logs --tail=50 || true
        fi

  rules:
    - if: $CI_COMMIT_TAG=~ /^deploy-production-v\d+\.\d+\.\d+$/

dast_scan:
  stage: dast
  image: ghcr.io/zaproxy/zaproxy:stable
  variables:
    # URLs específicas de tu API
    DAST_WEBSITE: "https://spvending.uksouth.cloudapp.azure.com"
    LOGIN_URL: "https://spvending.uksouth.cloudapp.azure.com/api/v1/auth/login"
    # Credenciales (mejor moverlas a CI/CD Variables por seguridad)
    LOGIN_USERNAME: "admin"
    LOGIN_PASSWORD: "admin123."
  script:
    # Iniciar ZAP daemon
    - zap.sh -daemon -host 0.0.0.0 -port 8080 -config api.disablekey=true &
    - echo "=== Iniciando análisis DAST para spvending API ==="
    - mkdir -p /zap/wrk
    - cd /zap/wrk
    - sleep 15

    # Verificar que ZAP está disponible
    - curl -s http://localhost:8080/JSON/core/view/version/ || (echo "ZAP no disponible" && exit 1)
    - echo "ZAP versión:" && curl -s http://localhost:8080/JSON/core/view/version/

    # PASO 1: Login manual para obtener cookies
    - echo "=== Realizando login en la API ==="
    - |
      echo "Haciendo login en: $LOGIN_URL"
      
      # Hacer login y capturar cookies + respuesta
      LOGIN_RESPONSE=$(curl -s -c /zap/wrk/cookies.txt -b /zap/wrk/cookies.txt \
        -X POST "$LOGIN_URL" \
        -H "Content-Type: application/json" \
        -H "Accept: application/json" \
        -d '{"username":"'$LOGIN_USERNAME'","password":"'$LOGIN_PASSWORD'"}' \
        -w "HTTPSTATUS:%{http_code}" \
        -o /zap/wrk/login_response.json)
      
      # Extraer código de estado
      HTTP_STATUS=$(echo $LOGIN_RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
      echo "Login HTTP Status: $HTTP_STATUS"
      
      if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
        echo "✅ Login exitoso"
        echo "Respuesta del login:"
        cat /zap/wrk/login_response.json | jq . 2>/dev/null || cat /zap/wrk/login_response.json
        echo ""
        echo "Cookies obtenidas:"
        cat /zap/wrk/cookies.txt
      else
        echo "❌ Error en login - Status: $HTTP_STATUS"
        echo "Respuesta:"
        cat /zap/wrk/login_response.json
        exit 1
      fi

    # PASO 2: Configurar contexto ZAP con autenticación
    - echo "=== Configurando contexto de autenticación en ZAP ==="
    - |
      # Crear hook de autenticación personalizado
      cat > /zap/wrk/auth_hook.py << 'EOF'
      import json
      import requests
      import os
      import time
      
      def zap_started(zap, target):
          print("=== Hook: ZAP iniciado, configurando autenticación ===")
      
          login_url = "https://spvending.uksouth.cloudapp.azure.com/api/v1/auth/login"
          username = "admin"
          password = "admin123"
      
          try:
              # Hacer login
              session = requests.Session()
              login_data = {"username": username, "password": password}
      
              print(f"Haciendo login en: {login_url}")
              response = session.post(login_url, json=login_data, timeout=30)
              print(f"Login status: {response.status_code}")
      
              if response.status_code in [200, 201]:
                  print("Login exitoso")
      
                  # Añadir cookies a ZAP
                  for cookie in session.cookies:
                      cookie_str = f"{cookie.name}={cookie.value}"
                      print(f"Añadiendo cookie: {cookie_str}")
                      try:
                          zap.httpsessions.add_session_token(target, cookie_str)
                      except Exception as e:
                          print(f"Error añadiendo cookie: {e}")
      
                  # Hacer una petición de prueba
                  test_response = session.get(f"{target}/api/v1", timeout=10)
                  print(f"Test request status: {test_response.status_code}")
      
              else:
                  print(f"Error en login: {response.status_code}")
                  print(f"Response: {response.text}")
      
          except Exception as e:
              print(f"Error en hook de autenticación: {e}")
      
      def zap_pre_shutdown(zap):
          print("=== Hook: Finalizando escaneo ===")
      EOF
      
      # Crear contexto con configuración básica
      CONTEXT_RESPONSE=$(curl -s -X POST "http://localhost:8080/JSON/context/action/newContext/" \
        -d "contextName=SpvendingAuth")
      CONTEXT_ID=$(echo $CONTEXT_RESPONSE | jq -r '.contextId // "0"')
      echo "Context ID creado: $CONTEXT_ID"
      
      # Incluir la API en el contexto
      curl -s -X POST "http://localhost:8080/JSON/context/action/includeInContext/" \
        -d "contextName=SpvendingAuth&regex=https://spvending\.uksouth\.cloudapp\.azure\.com.*"
      
      echo "Contexto básico configurado"

    # PASO 3: Importar cookies a ZAP
    - echo "=== Importando cookies a ZAP ==="
    - |
      if [ -f /zap/wrk/cookies.txt ]; then
        # Leer cookies y añadirlas a ZAP
        while IFS=$'\t' read -r domain flag path secure expiration name value; do
          if [[ "$domain" != \#* ]] && [[ -n "$name" ]] && [[ -n "$value" ]]; then
            echo "Añadiendo cookie: $name"
            curl -s -X POST "http://localhost:8080/JSON/httpsessions/action/addSessionToken/" \
              -d "site=$DAST_WEBSITE&sessionToken=$name%3D$value" || true
          fi
        done < /zap/wrk/cookies.txt
      fi

    # PASO 4: Verificar autenticación con una petición de prueba
    - echo "=== Verificando autenticación ==="
    - |
      # Probar acceso a un endpoint protegido (ajustar según tu API)
      TEST_ENDPOINTS=(
        "/api/v1/users"
        "/api/v1/admin"
        "/api/v1/dashboard"
        "/api/v1/profile"
      )
      
      for endpoint in "${TEST_ENDPOINTS[@]}"; do
        echo "Probando endpoint: $DAST_WEBSITE$endpoint"
        TEST_STATUS=$(curl -s -b /zap/wrk/cookies.txt \
          -H "Accept: application/json" \
          -w "%{http_code}" \
          -o /tmp/test_response.txt \
          "$DAST_WEBSITE$endpoint")
      
        echo "Status: $TEST_STATUS"
        if [ "$TEST_STATUS" = "200" ]; then
          echo "✅ Autenticación verificada en $endpoint"
          break
        elif [ "$TEST_STATUS" = "401" ] || [ "$TEST_STATUS" = "403" ]; then
          echo "⚠️ Sin acceso a $endpoint (Status: $TEST_STATUS)"
        else
          echo "ℹ️ Endpoint $endpoint devolvió $TEST_STATUS"
        fi
      done

    # PASO 5: Ejecutar escaneo DAST
    - echo "=== Iniciando escaneo DAST autenticado ==="
    - |
      # Crear directorio para outputs de ZAP
      mkdir -p /home/zap
      
      # Ejecutar baseline scan con autenticación y configuración mejorada
      zap-baseline.py -t $DAST_WEBSITE \
        -r zap_report.html \
        -n SpvendingAuth \
        -U admin \
        -J zap_json_report.json \
        -x zap_xml_report.xml \
        -w zap_md_report.md \
        --hook /zap/wrk/auth_hook.py \
        -z "-config spider.maxDepth=3 \
            -config spider.maxChildren=10 \
            -config scanner.strength=LOW \
            -config spider.postform=true \
            -config spider.processform=true" \
        2>&1 | tee zap_scan.log || echo "Escaneo completado con warnings"

    # PASO 6: Procesar resultados
    - echo "=== Procesando resultados ==="
    - ls -la /zap/wrk/

    # Verificar que el reporte se generó
    - |
      if [ ! -f /zap/wrk/zap_report.html ]; then
        echo "❌ Error: Reporte no generado"
        echo "Log del escaneo:"
        cat zap_scan.log || echo "No hay log disponible"
        exit 1
      fi

    # Copiar archivos
    - cp /zap/wrk/zap_report.html $CI_PROJECT_DIR/ 2>/dev/null || echo "No se pudo copiar HTML report"
    - cp /zap/wrk/zap_json_report.json $CI_PROJECT_DIR/ 2>/dev/null || echo "No se pudo copiar JSON report"
    - cp /zap/wrk/zap_xml_report.xml $CI_PROJECT_DIR/ 2>/dev/null || echo "No se pudo copiar XML report"
    - cp /zap/wrk/zap_md_report.md $CI_PROJECT_DIR/ 2>/dev/null || echo "No se pudo copiar MD report"
    - cp /zap/wrk/zap_scan.log $CI_PROJECT_DIR/ 2>/dev/null || echo "No se pudo copiar scan log"
    - cp /zap/wrk/login_response.json $CI_PROJECT_DIR/ 2>/dev/null || echo "No se pudo copiar login response"

    # Generar resumen
    - echo "=== Resumen del análisis DAST ==="
    - |
      if [ -f zap_report.html ]; then
        echo "📊 Estadísticas del escaneo:"
      
        # Contar vulnerabilidades por riesgo
        HIGH_COUNT=$(grep -i "risk-3\|high.*risk" zap_report.html | wc -l || echo "0")
        MEDIUM_COUNT=$(grep -i "risk-2\|medium.*risk" zap_report.html | wc -l || echo "0")
        LOW_COUNT=$(grep -i "risk-1\|low.*risk" zap_report.html | wc -l || echo "0")
        INFO_COUNT=$(grep -i "risk-0\|informational" zap_report.html | wc -l || echo "0")
      
        echo "🔴 Alto riesgo: $HIGH_COUNT"
        echo "🟡 Medio riesgo: $MEDIUM_COUNT"
        echo "🟢 Bajo riesgo: $LOW_COUNT"
        echo "ℹ️ Informacional: $INFO_COUNT"
      
        # Extraer URLs escaneadas
        SCANNED_URLS=$(grep -o "https://spvending[^\"]*" zap_report.html | sort -u | wc -l || echo "0")
        echo "🔍 URLs escaneadas: $SCANNED_URLS"
      
        echo ""
        echo "📋 Top 5 URLs encontradas:"
        grep -o "https://spvending[^\"]*" zap_report.html | sort -u | head -5 || echo "No se encontraron URLs"
      fi

  artifacts:
    paths:
      - zap_report.html
      - zap_json_report.json
      - zap_xml_report.xml
      - zap_md_report.md
      - zap_scan.log
      - login_response.json
    reports:
      dast: zap_json_report.json
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG =~ /^deploy-production-v\d+\.\d+\.\d+$/
  allow_failure: true
