image: docker:latest
include:
variables:
  DOCKER_DRIVER: overlay2
  DOCKER_HOST: unix:///var/run/docker.sock
  IMAGE_NAME_BASE: "$CI_REGISTRY/smart-vending/spvending-managment"
  IMAGE_NAME: "$CI_REGISTRY_IMAGE:$CI_COMMIT_TAG"
  DAST_WEBSITE: "https://spvending.uksouth.cloudapp.azure.com"
  GIT_DEPTH: "0"
stages:
  - test
  - build
  - deploy_staging
  - deploy_production
  - dast
dependency_check:
  stage: test
  tags:
    - test
  image: maven:3.9.6-eclipse-temurin-22
  script:
      - mvn org.owasp:dependency-check-maven:check
      - |
          if grep -q "<severity>Critical</severity>" target/dependency-check-report/dependency-check-report.xml; then
            echo "❌ Vulnerabilidades críticas detectadas"; exit 1;
          fi
  artifacts:
      when: always
      paths:
        - target/dependency-check-report/dependency-check-report.html
        - target/dependency-check-report/dependency-check-report.xml
      reports:
        dependency_scanning: target/dependency-check-report/dependency-check-report.xml
  rules:
    - if: $CI_COMMIT_TAG=~ /^v\d+\.\d+\.\d+$/
      when: always
sonarqube:
  image: maven:3.9-eclipse-temurin-22
  stage: test
  tags:
    - sonar
  variables:
    SONAR_USER_HOME: "${CI_PROJECT_DIR}/.sonar"
  cache:
    key: "${CI_JOB_NAME}"
    paths:
      - .sonar/cache
  script:
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
              git fetch origin main
              if git branch -r --contains "$CI_COMMIT_TAG" | grep -q "origin/main"; then
                echo "Iniciando análisis con SonarQube..."
                mvn clean verify
                apt-get update && apt-get install -y wget unzip
                wget https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/sonar-scanner-cli-5.0.1.3006-linux.zip
                unzip sonar-scanner-cli-5.0.1.3006-linux.zip
                mv sonar-scanner-5.0.1.3006-linux sonar-scanner
                export PATH=$PATH:$(pwd)/sonar-scanner/bin
                echo "El tag proviene de main. Ejecutando análisis..."
                sonar-scanner -X -Dsonar.projectVersion=${CI_COMMIT_TAG} -Dsonar.token=$SONAR_TOKEN
              else
                echo "El tag NO proviene de main. Saltando análisis."
              fi
            else
              echo "No es un tag. Saltando análisis."
      fi

  rules:
    - if: $CI_COMMIT_TAG=~ /^v\d+\.\d+\.\d+$/
      when: always

build_image:
  stage: build
  tags:
    - build
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        git fetch origin main
        if git branch -r --contains "$CI_COMMIT_SHA" | grep -q "origin/main"; then
                  docker build -t "$IMAGE_NAME" .
                  docker push "$IMAGE_NAME"
          else
              echo "El tag NO proviene de main. Saltando build."
        fi
          else
            echo "No es un tag. Saltando build."
      fi

  rules:
    - if: $CI_COMMIT_TAG=~ /^v\d+\.\d+\.\d+$/
      when: always

deploy_app_staging:
  stage: deploy_staging
  tags:
    - deploy
  services: []
  variables:
    COMPOSE_PROJECT_NAME: "spvending-managment-staging"
    DOCKER_HOST: "unix:///var/run/docker.sock"
  before_script:
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - |
      if [ -n "$CI_COMMIT_TAG" ]; then
        git fetch origin main
        if git branch -r --contains "$CI_COMMIT_TAG" | grep -q "origin/main"; then
          export DEPLOY_TAG="${CI_COMMIT_TAG#deploy-staging-}"
          echo "=== DESPLEGANDO VERSIÓN ==="
          docker pull "$CI_REGISTRY_IMAGE:$DEPLOY_TAG"
          docker-compose -f docker-compose-staging.deploy.yml down --remove-orphans
          docker-compose -f docker-compose-staging.deploy.yml up -d 
          echo "=== CONTENEDORES EN EJECUCIÓN ==="
          docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Ports}}"
        else
          echo "El tag NO proviene de main. Saltando build."
        fi
      else
        echo "No es un tag. Saltando build."
      fi
  after_script:
    - docker logout $CI_REGISTRY
  rules:
    - if: $CI_COMMIT_TAG=~ /^deploy-staging-v\d+\.\d+\.\d+$/

deploy_app_production:
  stage: deploy_production
  tags:
    - azure
  services: []
  variables:
    COMPOSE_PROJECT_NAME: "spvending-managment-production"
    DOCKER_HOST: "unix:///var/run/docker.sock"
  before_script:
    - echo "=== Autenticando con GitLab Registry ==="
    - echo "$CI_REGISTRY_PASSWORD" | docker login -u "$CI_REGISTRY_USER" --password-stdin "$CI_REGISTRY"
  script:
    - |
      if [[ "$CI_COMMIT_TAG" =~ ^deploy-production-v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        git fetch origin main
        if git branch -r --contains "$CI_COMMIT_SHA" | grep -q "origin/main"; then
          echo "=== Preparando despliegue ==="
          # Crear directorio de trabajo si no existe
          mkdir -p ~/spvending/api
          cd ~/spvending/api
        
          echo "=== Copiar docker-compose desde el repositorio ==="
          cp $CI_PROJECT_DIR/docker-compose-production.deploy.yml ./
  
          echo "=== Parando contenedores existentes ==="
          docker-compose -f docker-compose-production.deploy.yml down --remove-orphans || true
          
          echo "=== Iniciando despliegue para $CI_COMMIT_TAG ===" 
          export DEPLOY_TAG="${CI_COMMIT_TAG#deploy-production-}"
          IMAGE_NAME="$CI_REGISTRY_IMAGE:$DEPLOY_TAG"
        
          echo "=== Descargando imagen $IMAGE_NAME ==="
          docker pull "$IMAGE_NAME"
        
          echo "=== Iniciando nuevos contenedores ==="
          docker-compose -f docker-compose-production.deploy.yml up -d
        
          echo "=== Verificando estado de contenedores ==="
          docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Status}}\t{{.Ports}}"
        
          echo "=== Limpiando imágenes no utilizadas ==="
          docker image prune -af
          echo "=== Despliegue completado exitosamente ==="
          exit 0
        else
          echo "El tag NO proviene de main. Saltando despliegue."
          exit 0
        fi
      else
        echo "No es un tag de despliegue válido. Saltando..."
        echo "Tag recibido: $CI_COMMIT_TAG"
        echo "Formato esperado: deploy-production-v[X.Y.Z]"
        exit 0
      fi
  after_script:
      - docker logout $CI_REGISTRY
      - |
        if [ "$CI_JOB_STATUS" != "success" ]; then
          echo "=== Logs de contenedores para debug ==="
          docker-compose -f ~/deployment/docker-compose-production.deploy.yml logs --tail=50 || true
        fi

  rules:
    - if: $CI_COMMIT_TAG=~ /^deploy-production-v\d+\.\d+\.\d+$/

dast_scan:
  stage: dast
  image: ghcr.io/zaproxy/zaproxy:stable
  variables:
    # URLs específicas de tu API
    DAST_WEBSITE: "https://spvending.uksouth.cloudapp.azure.com"
    LOGIN_URL: "https://spvending.uksouth.cloudapp.azure.com/api/v1/auth/login"
    # Credenciales (mejor moverlas a CI/CD Variables por seguridad)
    LOGIN_USERNAME: "admin"
    LOGIN_PASSWORD: "admin123."
  script:
    # Iniciar ZAP daemon
    - zap.sh -daemon -host 0.0.0.0 -port 8080 -config api.disablekey=true &
    - echo "=== Iniciando análisis DAST para spvending API ==="
    - mkdir -p /zap/wrk
    - cd /zap/wrk
    - sleep 15

    # Verificar que ZAP está disponible
    - curl -s http://localhost:8080/JSON/core/view/version/ || (echo "ZAP no disponible" && exit 1)
    - echo "ZAP versión:" && curl -s http://localhost:8080/JSON/core/view/version/

    # PASO 1: Login manual para obtener cookies
    - echo "=== Realizando login en la API ==="
    - |
      echo "Haciendo login en: $LOGIN_URL"
      
      # Hacer login y capturar cookies + respuesta
      LOGIN_RESPONSE=$(curl -s -c /zap/wrk/cookies.txt -b /zap/wrk/cookies.txt \
        -X POST "$LOGIN_URL" \
        -H "Content-Type: application/json" \
        -H "Accept: application/json" \
        -d '{"username":"'$LOGIN_USERNAME'","password":"'$LOGIN_PASSWORD'"}' \
        -w "HTTPSTATUS:%{http_code}" \
        -o /zap/wrk/login_response.json)
      
      # Extraer código de estado
      HTTP_STATUS=$(echo $LOGIN_RESPONSE | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
      echo "Login HTTP Status: $HTTP_STATUS"
      
      if [ "$HTTP_STATUS" = "200" ] || [ "$HTTP_STATUS" = "201" ]; then
        echo "✅ Login exitoso"
        echo "Respuesta del login:"
        cat /zap/wrk/login_response.json | jq . 2>/dev/null || cat /zap/wrk/login_response.json
        echo ""
        echo "Cookies obtenidas:"
        cat /zap/wrk/cookies.txt
      else
        echo "❌ Error en login - Status: $HTTP_STATUS"
        echo "Respuesta:"
        cat /zap/wrk/login_response.json
        exit 1
      fi

    # PASO 2: Configurar contexto ZAP con autenticación
    - echo "=== Configurando contexto de autenticación en ZAP ==="
    - |
      # Crear hook de autenticación personalizado
      cat > /zap/wrk/auth_hook.py << 'EOF'
      import json
      import requests
      import os
      import time
      
      def zap_started(zap, target):
          print("=== Hook: ZAP iniciado, configurando autenticación ===")
      
          login_url = "https://spvending.uksouth.cloudapp.azure.com/api/v1/auth/login"
          username = "admin"
          password = "admin123."
      
          try:
              # Hacer login
              session = requests.Session()
              login_data = {"username": username, "password": password}
      
              print(f"Haciendo login en: {login_url}")
              response = session.post(login_url, json=login_data, timeout=30)
              print(f"Login status: {response.status_code}")
      
              if response.status_code in [200, 201]:
                  print("Login exitoso")
      
                  # Añadir cookies a ZAP
                  for cookie in session.cookies:
                      cookie_str = f"{cookie.name}={cookie.value}"
                      print(f"Añadiendo cookie: {cookie_str}")
                      try:
                          zap.httpsessions.add_session_token(target, cookie_str)
                      except Exception as e:
                          print(f"Error añadiendo cookie: {e}")
      
                  # Hacer una petición de prueba
                  test_response = session.get(f"{target}/api/v1", timeout=10)
                  print(f"Test request status: {test_response.status_code}")
      
              else:
                  print(f"Error en login: {response.status_code}")
                  print(f"Response: {response.text}")
      
          except Exception as e:
              print(f"Error en hook de autenticación: {e}")
      
      def zap_pre_shutdown(zap):
          print("=== Hook: Finalizando escaneo ===")
      EOF
      
      # Crear contexto con configuración básica - FIX: Mejorar manejo de errores
      echo "Creando contexto ZAP..."
      CONTEXT_RESPONSE=$(curl -s -X POST "http://localhost:8080/JSON/context/action/newContext/" \
        -d "contextName=SpvendingAuth" 2>/dev/null)
      
      echo "Respuesta del contexto: $CONTEXT_RESPONSE"
      
      # Verificar si la respuesta es JSON válido antes de usar jq
      if echo "$CONTEXT_RESPONSE" | jq . >/dev/null 2>&1; then
        CONTEXT_ID=$(echo "$CONTEXT_RESPONSE" | jq -r '.contextId // "0"')
        echo "Context ID extraído: $CONTEXT_ID"
      else
        echo "Respuesta no es JSON válido, usando ID por defecto"
        CONTEXT_ID="0"
      fi
      
      # Incluir la API en el contexto
      echo "Incluyendo API en contexto..."
      curl -s -X POST "http://localhost:8080/JSON/context/action/includeInContext/" \
        -d "contextName=SpvendingAuth&regex=https://spvending\.uksouth\.cloudapp\.azure\.com.*" 2>/dev/null
      
      echo "Contexto básico configurado con ID: $CONTEXT_ID"

    # PASO 3: Importar cookies a ZAP - MEJORADO
    - echo "=== Importando cookies a ZAP ==="
    - |
      if [ -f /zap/wrk/cookies.txt ]; then
        echo "Archivo de cookies encontrado, procesando..."
      
        # Leer cookies y añadirlas a ZAP
        while IFS=$'\t' read -r domain flag path secure expiration name value; do
          # Saltar comentarios y líneas vacías
          if [[ "$domain" != \#* ]] && [[ -n "$name" ]] && [[ -n "$value" ]]; then
            echo "Añadiendo cookie: $name"
      
            # Intentar añadir cookie con manejo de errores
            COOKIE_RESULT=$(curl -s -X POST "http://localhost:8080/JSON/httpsessions/action/addSessionToken/" \
              -d "site=$DAST_WEBSITE&sessionToken=$name%3D$value" 2>/dev/null)
      
            echo "Resultado cookie $name: $COOKIE_RESULT"
          fi
        done < /zap/wrk/cookies.txt
      
        echo "Cookies procesadas"
      else
        echo "No se encontró archivo de cookies"
      fi

    # PASO 4: Verificar autenticación con una petición de prueba
    - echo "=== Verificando autenticación ==="
    - |
      # Probar acceso a un endpoint protegido (ajustar según tu API)
      TEST_ENDPOINTS=(
        "/api/v1/users"
        "/api/v1/admin"
        "/api/v1/dashboard"
        "/api/v1/profile"
      )
      
      AUTH_VERIFIED=false
      
      for endpoint in "${TEST_ENDPOINTS[@]}"; do
        echo "Probando endpoint: $DAST_WEBSITE$endpoint"
        TEST_STATUS=$(curl -s -b /zap/wrk/cookies.txt \
          -H "Accept: application/json" \
          -w "%{http_code}" \
          -o /tmp/test_response.txt \
          "$DAST_WEBSITE$endpoint" 2>/dev/null)
      
        echo "Status: $TEST_STATUS"
        if [ "$TEST_STATUS" = "200" ]; then
          echo "✅ Autenticación verificada en $endpoint"
          AUTH_VERIFIED=true
          break
        elif [ "$TEST_STATUS" = "401" ] || [ "$TEST_STATUS" = "403" ]; then
          echo "⚠️ Sin acceso a $endpoint (Status: $TEST_STATUS)"
        else
          echo "ℹ️ Endpoint $endpoint devolvió $TEST_STATUS"
        fi
      done
      
      if [ "$AUTH_VERIFIED" = "false" ]; then
        echo "⚠️ No se pudo verificar autenticación en endpoints de prueba"
        echo "Continuando con el escaneo básico..."
      fi

    # PASO 5: Ejecutar escaneo DAST - SIMPLIFICADO PARA EVITAR ERRORES
    - echo "=== Iniciando escaneo DAST autenticado ==="
    - |
      # Asegurar que estamos en el directorio correcto
      cd /zap/wrk
      
      # Ejecutar baseline scan con configuración simplificada
      echo "Ejecutando zap-baseline.py..."
      
      zap-baseline.py -t $DAST_WEBSITE \
        -r zap_report.html \
        -J zap_json_report.json \
        -x zap_xml_report.xml \
        -w zap_md_report.md \
        --hook /zap/wrk/auth_hook.py \
        -z "-config scanner.strength=LOW" \
        2>&1 | tee zap_scan.log
      
      # Capturar el código de salida pero no fallar por warnings
      SCAN_EXIT_CODE=$?
      echo "Código de salida del escaneo: $SCAN_EXIT_CODE"
      
      if [ $SCAN_EXIT_CODE -eq 0 ] || [ $SCAN_EXIT_CODE -eq 2 ]; then
        echo "✅ Escaneo completado (código: $SCAN_EXIT_CODE)"
      else
        echo "⚠️ Escaneo completado con código: $SCAN_EXIT_CODE"
      fi

    # PASO 6: Verificar y procesar resultados
    - echo "=== Procesando resultados ==="
    - |
      echo "Archivos en directorio de trabajo:"
      ls -la /zap/wrk/
      
      # Verificar que al menos el reporte principal se generó
      if [ -f /zap/wrk/zap_report.html ]; then
        echo "✅ Reporte HTML generado correctamente"
      
        # Copiar archivos al directorio del proyecto
        echo "Copiando archivos de reporte..."
        cp /zap/wrk/zap_report.html $CI_PROJECT_DIR/ && echo "✅ HTML report copiado"
        cp /zap/wrk/zap_json_report.json $CI_PROJECT_DIR/ 2>/dev/null && echo "✅ JSON report copiado" || echo "⚠️ JSON report no disponible"
        cp /zap/wrk/zap_xml_report.xml $CI_PROJECT_DIR/ 2>/dev/null && echo "✅ XML report copiado" || echo "⚠️ XML report no disponible"
        cp /zap/wrk/zap_md_report.md $CI_PROJECT_DIR/ 2>/dev/null && echo "✅ MD report copiado" || echo "⚠️ MD report no disponible"
        cp /zap/wrk/zap_scan.log $CI_PROJECT_DIR/ 2>/dev/null && echo "✅ Scan log copiado" || echo "⚠️ Scan log no disponible"
        cp /zap/wrk/login_response.json $CI_PROJECT_DIR/ 2>/dev/null && echo "✅ Login response copiado" || echo "⚠️ Login response no disponible"
      
      else
        echo "❌ Error: Reporte HTML no generado"
        echo "Contenido del directorio de trabajo:"
        find /zap/wrk -type f -name "*.html" -o -name "*.json" -o -name "*.xml" -o -name "*.log" | head -10
      
        echo "Últimas líneas del log de escaneo:"
        tail -20 /zap/wrk/zap_scan.log 2>/dev/null || echo "No hay log disponible"
      
        # No fallar completamente, pero marcar como warning
        echo "⚠️ Escaneo incompleto, pero continuando..."
      fi

    # PASO 7: Generar resumen
    - echo "=== Resumen del análisis DAST ==="
    - |
      echo "📋 Estado final:"
      echo "- Directorio de trabajo: $(pwd)"
      echo "- Archivos disponibles:"
      ls -la $CI_PROJECT_DIR/zap_* 2>/dev/null || echo "  No hay archivos zap_* en directorio del proyecto"
      
      if [ -f $CI_PROJECT_DIR/zap_report.html ]; then
        echo ""
        echo "📊 Análisis de vulnerabilidades:"
      
        # Buscar patrones de vulnerabilidades en el reporte
        if command -v grep >/dev/null 2>&1; then
          HIGH_COUNT=$(grep -i "high\|critical" $CI_PROJECT_DIR/zap_report.html | wc -l 2>/dev/null || echo "0")
          MEDIUM_COUNT=$(grep -i "medium" $CI_PROJECT_DIR/zap_report.html | wc -l 2>/dev/null || echo "0")
          LOW_COUNT=$(grep -i "low" $CI_PROJECT_DIR/zap_report.html | wc -l 2>/dev/null || echo "0")
      
          echo "🔴 Alto/Crítico: $HIGH_COUNT menciones"
          echo "🟡 Medio: $MEDIUM_COUNT menciones"
          echo "🟢 Bajo: $LOW_COUNT menciones"
        fi
      
        echo ""
        echo "✅ Reporte DAST generado exitosamente"
        echo "📄 Consultar zap_report.html para detalles completos"
      else
        echo "⚠️ No se pudo generar el reporte completo"
      fi

  artifacts:
    paths:
      - zap_report.html
      - zap_json_report.json
      - zap_xml_report.xml
      - zap_md_report.md
      - zap_scan.log
      - login_response.json
    reports:
      dast: zap_json_report.json
    expire_in: 1 week
    when: always
  rules:
    - if: $CI_COMMIT_TAG =~ /^deploy-production-v\d+\.\d+\.\d+$/
  allow_failure: true
